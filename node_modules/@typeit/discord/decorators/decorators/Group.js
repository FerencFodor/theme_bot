"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Group = void 0;
const __1 = require("../..");
const DGroup_1 = require("../classes/DGroup");
function Group(groupOrSubcommands, subCommandsOrDescription, subCommands) {
    return (target, key, descriptor) => {
        // Detect the type of parameters for overloading
        const isGroup = typeof groupOrSubcommands === "string";
        const group = isGroup ? groupOrSubcommands.toLocaleLowerCase() : undefined;
        const isDescription = typeof subCommandsOrDescription === "string";
        const description = isDescription ? subCommandsOrDescription : undefined;
        if (subCommandsOrDescription !== undefined && !isDescription) {
            subCommands = subCommandsOrDescription;
        }
        subCommands = isGroup ? subCommands : groupOrSubcommands;
        if (!descriptor) {
            // Add the group to groups if @Group decorate a class
            if (group) {
                const group = DGroup_1.DGroup.create(groupOrSubcommands || key, { description }).decorate(target, target.name);
                __1.MetadataStorage.instance.addGroup(group);
            }
            // Create a subgroup if @Group decorate a method
            if (subCommands) {
                Object.keys(subCommands).map((key) => {
                    const group = DGroup_1.DGroup.create(key, { description: subCommands[key] }).decorate(target, target.name);
                    __1.MetadataStorage.instance.addSubGroup(group);
                });
            }
        }
        else {
            // If @Group decorate a method edit the method and add it to subgroup
            __1.MetadataStorage.instance.addModifier(__1.Modifier.create(async (original) => {
                original.subgroup = group;
            }, __1.DSlash).decorate(target.constructor, key));
        }
    };
}
exports.Group = Group;
//# sourceMappingURL=Group.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Method = void 0;
const __1 = require("../..");
const Decorator_1 = require("./Decorator");
class Method extends Decorator_1.Decorator {
    constructor() {
        super(...arguments);
        this._guards = [];
    }
    get discord() {
        return this._discord;
    }
    set discord(value) {
        this._discord = value;
    }
    /**
     * Compiled methods executes all the guards and the main method
     * ```ts
     * compiledMethod = async (params: ArgsOf<any>, client: Client) => {
     *   guard1(params, client)
     *   guard2(params, client)
     *   guard3(params, client)
     *   main(params, client)
     * }
     * ```
     * @returns The function that execute everything
     */
    get execute() {
        return async (...params) => {
            return await this.getGuardFunction()(...params);
        };
    }
    /**
     * Returns all the guards of the application
     * The guards that are defined globaly with Client
     * The guards that decorate @Discord
     * The guards that decorate the method (this)
     */
    get guards() {
        const clientGuards = __1.Client.guards.map((guard) => __1.DGuard.create(guard.bind(undefined)));
        return [
            ...clientGuards,
            ...this.discord.guards,
            ...this._guards,
            __1.DGuard.create(this._method.bind(this._discord.instance))
        ];
    }
    set guards(value) {
        this._guards = value;
    }
    /**
     * Execute a guard with params
     */
    getGuardFunction() {
        const next = async (params, index, paramsToNext) => {
            const nextFn = () => next(params, index + 1, paramsToNext);
            const guardToExecute = this.guards[index];
            let res;
            if (index >= this.guards.length - 1) {
                // If it's the main method
                res = await guardToExecute.fn(
                // method(...ParsedOptions, [Interaction, Client], ...) => method(...ParsedOptions, Interaction, Client, ...)
                ...this.parseParams(...params), ...params, paramsToNext);
            }
            else {
                // If it's the guards
                // method([Interaction, Client])
                res = await guardToExecute.fn(...params, nextFn, paramsToNext);
            }
            if (res) {
                return res;
            }
            return paramsToNext;
        };
        return (...params) => next(params, 0, {});
    }
}
exports.Method = Method;
//# sourceMappingURL=Method.js.map
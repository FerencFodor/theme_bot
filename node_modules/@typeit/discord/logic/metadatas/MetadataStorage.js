"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataStorage = void 0;
const __1 = require("../..");
class MetadataStorage {
    constructor() {
        this._events = [];
        this._guards = [];
        this._slashes = [];
        this._allSlashes = [];
        this._options = [];
        this._discords = [];
        this._modifiers = [];
        this._groups = [];
        this._subGroups = [];
    }
    static get instance() {
        if (!this._instance) {
            this._instance = new MetadataStorage();
        }
        return this._instance;
    }
    static clear() {
        this._instance = new MetadataStorage();
    }
    get events() {
        return this._events;
    }
    /**
     * Get the list of used events without duplications
     */
    get usedEvents() {
        return this.events.reduce((prev, event, index) => {
            const found = this.events.find((event2) => event.event === event2.event);
            const foundIndex = this.events.indexOf(found);
            if (foundIndex === index || found.once !== event.once) {
                prev.push(event);
            }
            return prev;
        }, []);
    }
    get discords() {
        return this._discords;
    }
    get slashes() {
        return this._slashes;
    }
    get allSlashes() {
        return this._allSlashes;
    }
    get groups() {
        return this._groups;
    }
    get subGroups() {
        return this._subGroups;
    }
    get discordMembers() {
        return [
            ...this._slashes,
            ...this._events,
        ];
    }
    addModifier(modifier) {
        this._modifiers.push(modifier);
    }
    addOn(on) {
        this._events.push(on);
    }
    addSlash(slash) {
        this._slashes.push(slash);
    }
    addOption(option) {
        this._options.push(option);
    }
    addGroup(group) {
        this._groups.push(group);
    }
    addSubGroup(subGroup) {
        this._subGroups.push(subGroup);
    }
    addGuard(guard) {
        this._guards.push(guard);
        __1.DIService.instance.addService(guard.classRef);
    }
    addDiscord(discord) {
        this._discords.push(discord);
        __1.DIService.instance.addService(discord.classRef);
    }
    async build() {
        // Link the events with @Discord class instances
        this.discordMembers.filter((member) => {
            // Find the linked @Discord of an event
            const discord = this._discords.find((instance) => {
                return instance.from === member.from;
            });
            // You can get the @Discord that wrap a @Command/@On by using
            // on.discord or slash.discord
            member.discord = discord;
            if (member instanceof __1.DSlash) {
                discord.slashes.push(member);
            }
            if (member instanceof __1.DOn) {
                discord.events.push(member);
            }
        });
        await __1.Modifier.applyFromModifierListToList(this._modifiers, this._discords);
        await __1.Modifier.applyFromModifierListToList(this._modifiers, this._events);
        await __1.Modifier.applyFromModifierListToList(this._modifiers, this._slashes);
        await __1.Modifier.applyFromModifierListToList(this._modifiers, this._options);
        // Set the class level "group" property of all @Slash
        // Cannot achieve it using modifiers
        this._groups.map((group) => {
            this._slashes.map((slash) => {
                if (group.from !== slash.from) {
                    return;
                }
                slash.group = group.name;
            });
        });
        this._allSlashes = this._slashes;
        this._slashes = this.groupSlashes();
    }
    groupSlashes() {
        const groupedSlashes = new Map();
        // Create Slashes from class groups that will wraps the commands
        //
        // "name": "permissions",
        // "description": "Get or edit permissions for a user or a role",
        // "options": [
        //    ...comands
        // ]
        //
        this._groups.map((group) => {
            const slashParent = __1.DSlash.create(group.name, group.infos.description).decorate(group.classRef, group.key, group.method);
            slashParent.discord = this._discords.find((instance) => {
                return instance.from === slashParent.from;
            });
            slashParent.guilds = [
                ...__1.Client.slashGuilds,
                ...slashParent.discord.guilds
            ];
            slashParent.permissions = slashParent.discord.permissions;
            groupedSlashes.set(group.name, slashParent);
            const slashes = this._slashes.filter((slash) => {
                return slash.group === slashParent.name && !slash.subgroup;
            });
            slashes.map((slash) => {
                slashParent.options.push(slash.toSubCommand());
            });
        });
        // Create for each subgroup (@Group on methods) create an Option based on Slash
        //
        // "name": "permissions",
        // "description": "Get or edit permissions for a user or a role",
        // "options": [
        //    {
        //        "name": "user",
        //        "description": "Get or edit permissions for a user",
        //        "type": "SUB_COMMAND_GROUP"
        //        "options": [
        //            ....
        //        ]
        //     }
        // ]
        this._subGroups.map((subGroup) => {
            const option = __1.DOption.create(subGroup.name, "SUB_COMMAND_GROUP", subGroup.infos.description).decorate(subGroup.classRef, subGroup.key, subGroup.method);
            // Get the slashes that are in this subgroup
            const slashes = this._slashes.filter((slash) => {
                return slash.subgroup === option.name;
            });
            // Convert this slashes into options and add it to the option parent
            // this slashes are the node of the options
            //
            // "name": "permissions",
            // "description": "Get or edit permissions for a user or a role",
            // "options": [
            //     {
            //         "name": "user",
            //         "description": "Get or edit permissions for a user",
            //         "type": "SUB_COMMAND_GROUP"
            //         "options": [
            //             {
            //                 "name": "get",
            //                 "description": "Get permissions for a user",
            //                 "type": "SUB_COMMAND"
            //                 "options": [
            //                 ]
            //              }
            //          ]
            //      }
            // ]
            //
            slashes.map((slash) => {
                option.options.push(slash.toSubCommand());
            });
            // The the root option to the root Slash command
            const groupSlash = groupedSlashes.get(slashes[0].group);
            if (groupSlash) {
                groupSlash.options.push(option);
            }
        });
        return [
            ...this._slashes.filter((s) => !s.group && !s.subgroup),
            ...Array.from(groupedSlashes.values())
        ];
    }
    /**
     * Trigger a discord event
     * @param event The event to trigger
     * @param client The discord.ts client instance
     * @param once Should we execute the event once
     */
    trigger(event, client, once = false) {
        const responses = [];
        const eventsToExecute = this._events.filter((on) => {
            return (on.event === event &&
                on.once === once);
        });
        return async (...params) => {
            for (const on of eventsToExecute) {
                const res = await on.execute(params, client);
                responses.push(res);
            }
            return responses;
        };
    }
}
exports.MetadataStorage = MetadataStorage;
//# sourceMappingURL=MetadataStorage.js.map